# Requirements: return k, where k is the number of non-zero elements;
# the first k elements of nums should be these non-zero elements.

#### Python ####
# A trivial approach:
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        temp = sorted(list(set(nums)))
        for i in range(len(temp)):
            nums[i] = temp[i]
        return len(temp)

# Since the first element cannot be a duplicate by definition,
# we can maintain a target index 'j' to track the position of the next unique element.
# If the current number is different from the previous one,
# we place it at index j and increment j.
# This way, the first 'k' elements in nums are unique,
# but the length of nums remains unchanged.
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        j = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1]:
                nums[j] = nums[i]
                j += 1
        return j

# solution1: does not work as it only returns the count of unique elements,
# but does not modify the original array in place.
# return len(set(nums))

# Explanation from sumanshekhar698:
# Not only do you have to return the number of unique elements (say 'x'),
# but you also need to modify the original array 'nums' such that
# the first x positions contain these unique elements.

#### C++ ####
class Solution {
public:
    // vec.erase truly removes elements from the container,
    // std::remove moves all elements equal to a specific value to the end (does not change container size),
    // std::unique moves all duplicate consecutive elements to the end,
    // thus combining erase and unique removes duplicates correctly.
    int removeDuplicates(vector<int>& nums) {
        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());
        return nums.size();
    }
};
